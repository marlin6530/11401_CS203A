# 05-hash-table-no-code.md

# Hash Table（雜湊表）

## 定義

Hash Table 利用**雜湊函數（hash function）**，將「鍵（key）」對映到「索引」，進而儲存在底層陣列中。  
目標是讓插入、查詢、刪除都能在平均 (O(1)) 時間完成。

## 核心概念

- 雜湊函數：`key → 整數 → 陣列索引`
- 碰撞（collision）：不同 key 映射到同一個索引
- 裝載因子（load factor）：元素數 / bucket 數，影響效能

## 碰撞處理方式

1. **開放尋址法（Open Addressing）**
   - 線性探測（linear probing）：往後找下一個空位
   - 平方探測、雙重雜湊等變化
   - 優點：資料都在同一個陣列中
   - 缺點：容易形成「叢集」

2. **鏈結法（Chaining）**
   - 每個 bucket 存一個鏈結串列或動態容器
   - 碰撞時將新元素掛在同一 bucket 的串列後面
   - 優點：實作簡單，擴展彈性好
   - 缺點：記憶體額外開銷較高

## 時間複雜度（平均情況）

- 插入：(O(1))
- 查詢：(O(1))
- 刪除：(O(1))

最壞情況（雜湊全部撞在同一個 bucket）會退化到 (O(n))。

## 實際應用

- **學生系統**：以學號為 key，快速查詢學生資料
- **快取系統（Cache）**：以請求 key 對映到快取內容
- **詞頻統計**：字串 → 出現次數
- **IP→位置對映**：查詢某 IP 所屬地區
- **去重 / 查重**：判斷某元素是否出現過

## 優點

- 查詢、插入、刪除平均時間都很快：(O(1))
- 適合做「字典」、「表」、「索引」型需求
- 在實務中非常常見，語言標準庫幾乎都內建（如 C++ 的 `unordered_map`）

## 缺點

- 雜湊函數設計不良會導致效能下降
- 不維持元素順序，也不會自動排序
- 需要注意擴表、重雜湊（rehash）帶來的成本

## 何時使用 Hash Table

- 需要**快速查詢**，例如：
  - key → value 查詢
  - 判斷元素是否出現過
- 不在意資料的整體排序，只在意存不存在 / 對應值
